# Unix/Linux编程实践之线程机制

个人读书笔记

## 线程
fork和exec实现的是创建多个进程，那么如何要同时运行多个函数呢？

线程之于函数，就相当于进程之于程序。 很多函数可以同时运行，但它们都在相同的进程中。

其实在Linux中，新建的线程并不是在原先的进程中，而是系统通过一个系统调用clone()。 
该系统调用copy了一个和原先进程完全一样的进程，并在这个进程中执行线程函数。 
不过这个copy过程和fork不一样。 copy后的进程和原先的进程`共享了所有的变量，运行环境`。 
这样，原先进程中的变量变动在copy后的进程中便能体现出来。

### 进程和线程关于共享资源的对比
理解清楚这些概念非常重要。

Unix从其产生伊始就将线程作为它的重要组成部分，线程是后来才加进来的。 

进程的概念是非常清晰和统一的，而线程的概念和属性则取决于你的OS和线程版本。 本文所说的是`POSIX线程`。

进程和线程有根本上的不同。
  * 进程有独立的数据空间、文件描述符、进程ID。 
  * 而线程共享一个数据空间、文件描述符以及进程ID。

1. 共享数据空间  
试想两个线程同时使用一块内存空间，通过系统调用malloc和free，如果不加限制的，将会造成可怕的后果。

2. 共享的文件描述符  
在fork原语被调用之后，fd被自动地复制，从而子进程得到了一套新的fd。 在子进程关闭了某一个从父进程那里继承而来的fd之后，此fd对于父进程来说仍然是打开的。

然而，在多线程程序中，可能会把同一个fd传递给两个不同的线程。 即传递给两个线程的值指向同一个fd。 在这种情况下，如果一个线程关闭了这个文件，那么对于此进程中的所有线程来说，该fd都是已经关闭了的。 这会导致问题。。。。

3. fork、exec、exit、Signals  
所有的线程都共享一个进程。 
如果一个线程调用了`exec`，内核会用一个新的程序取代本进程当前的程序，从而所有正在运行的线程都会消失。

同理，一个线程执行了`exit`，那么整个进程都将退出。 所以，如果是线程的运行导致内存异常、系统错误或线程崩溃，都会造成整个进程瘫痪，而不仅仅是线程本身。

fork创建了一个新的进程，并把`原调用进程`的数据和代码复制给这个新的进程。 
如果一个线程中的某函数调用了`fork`，那么是不是把所有线程都复制给新的进程呢？ 
答案是否定的，只有调用了fork的线程在新的进程中运行。 
这里面设计的更加复杂了，如果在fork的时候有数据修改什么的。。。。

信号量Signal要比线程更加复杂。进程可以接收任何种类的信号量。那么线程呢？。。

## pthread相关系统调用

### pthread_create
创建线程的系统调用`pthread_create`,若成功则返回0，否则返回出错编号。
1. 第一个参数为指向线程标识符的指针。
2. 第二个参数用来设置线程属性，如果设置为NULL，则主进程需调用`pthread_join`等待本进程。可以设置为`detached`，线程自己来清理退出的状态、回收资源，不需要主进程等待。
3. 第三个参数是线程运行函数的起始地址。
4. 最后一个参数是运行函数的参数。
```c
int pthread_create(pthread_t *tidp, const pthread_attr_t *attr, (void*)(*start_rtn)(void*), void *arg);
```

### pthread_join
函数`pthread_join`用来等待一个线程的结束，是一个线程阻塞的函数，调用它的函数将一直等待到被等待的线程结束为止，当函数返回时，被等待线程的资源被收回。如果执行成功，将返回0，如果失败则返回一个错误号。
```c
int pthread_join(pthread_t thread, void **retval)
```

如果一个线程不设置为detached，主进程也不调用pthread_join，那么会产生`僵尸线程`，线程占用的资源无法得到回收。 
可以通过设置为独立线程（detached thread）解决，detached thread会自动释放它所占用的所有资源，它们自身甚至不允许等待其他线程返回。

### 一个例子
```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>
#include <string.h>

char st[20]="hello";//共享内存

void print_fn(const char *s){
    pid_t pid;
    pthread_t tid;
    pid = getpid();//进程id
    tid = pthread_self();//线程id
    printf("%s pid %u ,and tid %u\n", s, (unsigned int)pid, (unsigned int)tid);
}

void *new_pthread(void *arg){
    print_fn("I am a new pthread: ");
    return NULL;
}

int main(void){
    pthread_t tid;
    int err;
    err = pthread_create(&tid, NULL, new_pthread, NULL);
    if (err!=0)
        printf("occurs error while create new pthread: %s\n", strerror(err));
    print_fn("Main thread: ");
    pthread_join(tid, NULL);
    return 0;
}
```
执行效果如下，其中编译的时候需要加上编译链接`-lpthread`
```shell
[root@fqhnode01 c++]# cc ./pthread.c -o pthread -lpthread
[root@fqhnode01 c++]# ./pthread 
Main thread:  pid 1190 ,and tid 4010510144
I am a new pthread:  pid 1190 ,and tid 4002174720
```
可以发现主函数的流程总是要快于新线程先打印，应该是创建线程需要耗费时间。这和Go的Goroutine等待调度应该是类似的。

## 线程的通信
进程间可以通过管道、socket、信号、退出/等待、env来进行通信。 

线程间的通信要简单一点，多个线程在一个单独的进程中运行，它们共享全局变量。 因此，线程间可以通过设置和读取这些全局变量来进行通信。 其实这就是通过共享内存。

线程间共享内存，必然需要关注资源竞争问题，如互斥锁等。
```c
int pthread_mutex_lock(pthread_mutex_t *mutex);
int pthread_mutex_unlock(pthread_mutex_t *mutex);
```

进程的数据空间包含了所有属于它的变量。 因此，此进程中运行的所有线程都拥有对这些变量访问的权限。 
如果这些变量值不变的话，线程可以无误地读取并使用。 
但如果有一个线程更改了一个变量值，就需要上锁了。 
这是临界资源，在某一时刻，只能有唯一的线程对其进行访问。

### 和进程的差异
对于进程来说，父进程可以通过wait获取子进程的返回结果。 

那么线程呢？线程不具有这种机制。 
因为对于线程来说，没有父线程、子线程的概念。
所以不存在某一个明显的线程去通知。

一般来说，线程是通过`pthread_cond_wait()`把线程挂起，直到另外一个线程通过条件变量发出消息，常常和`互斥锁`一起使用。

## 线程的优点
现代线程库允许不同的线程运行在不同的处理器芯片上，从而实现真正意义上的并行。

## 总结
进程和线程的区别？
  - 调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位。
  - 拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源（寄存器、堆栈、上下文）。
  - 并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可以并发执行。
  - 私有属性：线程有自己的私有属性TCB，线程id，寄存器、硬件上下文，而进程也有自己的私有属性进程控制块PCB，这些私有属性是不被共享的，		用来标示一个进程或一个线程的标志。

线程是轻量级的进程，它的创建和销毁所需要的时间比进程小很多，所有操作系统中的执行功能都是创建线程去完成的。

没有说进程或者线程哪个更具具有绝对优势，各有优缺点！

在双核环境下，两个核可以分别单独运行两个进程（进程的并行，也是线程的并行，因为每个进程至少有一个线程）；或者是运行一个进程里的两个线程（线程的并行）

在单核cpu上运行多线程程序时，每一时刻，cpu只能运行一个线程。但由于操作系统会根据调度策略切换cpu运行的线程，所以看起来像是多线程在同时运行。

并行的必要条件是多核cpu！
同时真正处于running的线程数，不能超过cpu核数目！

多进程模式最大的优点就是稳定性高，因为一个子进程崩溃了，不会影响主进程和其他子进程。缺点是创建进程的代价大。

多线程模式致命的缺点就是任何一个线程挂掉都可能直接造成整个进程崩溃，因为所有线程共享进程的内存。

在多核的环境下，多线程性能上可能还不如多进程！

## 参考
[pthread系统调用](https://baike.baidu.com/item/pthread_join)

[关于进程、线程的一个最好的例子](https://www.zhihu.com/question/19901763/answer/13299543)

[processes_and_threads](http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html)