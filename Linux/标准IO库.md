# 标准I/O库

## 标准I/O、不带缓冲的I/O
open()、read()等不带缓冲的I/O函数都是基于一个文件描述符fd来进行操作的，而标准I/O库则是基于`流stream`的。

标准I/O库负责缓冲区分配、以优化的块长度来处理I/O等功能。

近30+年，标准I/O库基本上没怎么修改过，一如既往地稳定。

两者的关系：标准I/O为不带缓冲的I/O提供了一个带缓冲的接口。使用标准I/O无需担心如何选择最佳缓冲区大小。

当用标准I/O打开或创建一个文件时，已经使一个流与一个文件绑定。

## 流
`流的定向`，分为`单字节定向`和`多字节定向`，决定了该流所读写的字符是单字节还是多字节，可以通过wchar.h中函数来进行设定。

一个流在最初被创建的时候，是没有设置定向的。

只有两个函数可以设置一个流的定向：
1. freopen()，用于清除一个流的定向
2. fwide(FILE ＊fp, int mode)，用于设置一个流的定向。本函数并不会改变一个已定向流的定向。

当打开一个流的时候，标准I/O函数fopen()返回的是`一个指向FIFE对象的指针`。 
该对象通常是一个结构，包含了标准I/O库为管理一个流所需的全部信息，包括用于实际I/O的文件描述符fd、指向用于该流缓冲区的指针、缓冲区的长度、当前在缓冲区中的字符数与及出错标识等。

我们把指向该FIFE对象的指针，称为`文件指针`。

注意标准I/O函数fopen()和前面系统调用open()的`区别`，系统调用open()返回的仅仅是一个文件描述符fd，而这里返回的是一个包含fd的对象。

标准I/O库中和前面的类似，为一个进程定义了三个流，标准输入、标准输出、标准错误，定义在stdio.h中。

## 缓冲
标准I/O库提供缓冲的目的是尽可能地减少使用read和write的次数。它对每个I/O流自动地进行缓冲管理，从而避免在应用程序这一层来处理。
然而缓冲机制也正是标准I/O库中最令人困惑的地方。

标准I/O库有三种类型的缓冲：
### 全缓冲
只有填满标准I/O缓冲区之后才进行实际的I/O操作。对于驻留在磁盘上的文件通常是由标准I/O库实施全缓冲。

术语`冲洗flush`指的是标准I/O缓冲区的`写操作`。缓冲区可以由标准I/O例程自动地冲洗（在缓冲区被填满时），或者人工调用函数`fflush`来冲洗一个流。

在UNIX环境中，flush（冲洗）有两种意思：
1. 在标准I/O库中，flush意味着把缓冲区中的数据写入到磁盘上，该缓冲区可能仅仅是填充了部分数据
2. 在终端驱动程序方面，flush表示丢弃已经存储在缓冲区中的数据。

### 行缓冲
在输入输出中遇到换行符时，标准I/O库执行I/O操作。

当流涉及到一个终端时（如标准输入、标准输出），通常使用行缓冲。这样可以允许我们一次输入输出一个字符，但只有在写入了一行之后再进行实际的I/O操作。

行缓冲有两个限制：
1. 因为标准I/O库用来存储每一行的缓冲区的长度是固定的，所以只要填满了缓冲区，即使还没有写入一个换行符，也进行I/O操作
2. 任何时候通过标准I/O库来从 a)一个不带缓冲的流；或 b)一个行缓冲的流 中得到输入数据，那么就会冲洗所有行缓冲输出流。

需要说明的是，当从 b)一个行缓冲的流中读取数据时，是向内核发送请求希望读取数据，但所需的数据可能已经在该缓冲区中了，所以不会要求是从内核中读取数据。

同理，如果是从 a)一个不带缓冲的流中读取数据，就需要从内核中获取数据了。
### 不带缓冲
标准I/O库不会对字符进行缓冲存储，通用用于希望输入的内容能够立刻显示出来的场景。

标准错误流stderr通常是不带缓冲的，为了使错误信息尽快地显示。

### 小结
很多系统默认会采用下面的`缓冲机制`：标准错误流stder常是不带缓冲的，指向终端设备的流是行缓冲，其他的流则是全缓冲！

可以通过`setbuf`和`setvbuf`来打开关闭缓冲，或者更改缓冲类型。

最后，`fflush(FILE *fp)`可以强制冲洗一个流，使得该流中所有未写的数据都会被传送到内核。一个特殊的情况，如果fp为`NULL`，那么所有的流都会被冲洗。。。。

***

## 打开流
fopen()，基于一个指定路径来打开一个文件。

freopen()，在一个指定的流上打开一个指定的文件。此函数常用于将一个指定的文件打开为一个预先定义的流:标准输入、标准输出、标准错误

fdopen()，基于一个文件描述符fd来构建一个流。此函数常用于创建管道和网络通信管道函数返回的描述符，这类特殊的文件无法直接用fopen()打开，必须用fdopen()。

最后调用fclose(FILE *fp)来关闭一个已打开的流，在该文件关闭之前，冲洗缓冲区中的输出数据，而缓冲区中所有的`输入数据`将被`丢弃`。

可以发现这个和前面的系统调用提供的I/O是类似的，只是在其基础上增加了缓存。

当一个进程正常终止时（直接调用exit，或从main函数返回），则所有带未写缓冲数据的标准I/O流都会被冲洗，所有打开的标准I/O流都会被关闭。

## 非格式化I/O
一个流被打开了之后，如何进行读和写操作？有三种`非格式化`I/O方式：
1. 每次一个字符的I/O，一次仅读/写一个字符，使用fgetc、getc、getchar
2. 每次一行的I/O，使用fgets和fputs
3. 直接I/O，每次读/写一个对象，使用fread和fwrite。又被称为二进制I/O、一次一个对象I/O、面向记录的I/O、面向结构的I/O。

如果一个流是带缓冲的，读写操作之后，标准I/O库会处理缓冲区。

使用直接I/O的一个问题，就是只能用于读取在同一个系统上已写的数据。所以，在现在异构系统通过网络互联的复杂环境下，fread和fwrite可能不能正常工作。原因是：
  * 因为不同的对齐要求，在一个结构中，同一个成员的偏移量可能和编译程序、系统相关 
  * 用来存储多子节整数和浮点数的二进制格式在不同系统结构间也可能不同

现在一般在不同系统之间交换二进制数据的办法是使用互认的规范格式！

## 对一个流进行定位
可以使用ftell、fseek、ftello、fseeko和fgetpos、fsetpos三种方法对一个标准I/O流进行定位。

需要移植到非UNIX系统上运行的应用程序应当使用fgetpos、fsetpos

## 格式化I/O
1. 格式化输出

格式化输出由5个printf(）函数来处理，printf()将格式化数据写至标准输出，fprintf()写至指定的流，dprintf()写至指定的文件描述符fd，sprintf()则将格式化的字符送入数组buf中。

sprintf()函数可能会导致buf指向的缓冲区溢出，需要由调用者来确保安全。

2. 格式化输入

三个scanf()执行格式化输入处理，分析输入的字符串，并将其转化为指定类型的变量。

## 内存流
标准I/O库把数据缓存在内存中，因此每次一个字符、或每次一行的I/O更有效。

我们可以通过setbuf、setvbuf函数让I/O库使用自己设置的缓冲区，即`内存流`，也是`标准I/O流`。虽然仍然使用FILE指针进行访问，但其实并没有底层文件。所有的I/O都是通过缓冲区与主存之间来回传送字节来完成的。

这些流看起来像文件流，但它们的一些特征使其更适合用在字符串操作。

