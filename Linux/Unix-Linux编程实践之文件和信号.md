# Unix/Linux编程实践之文件、信号

个人读书笔记

## 内核提供的服务
内核（即os）对外提供服务，被称为系统调用。 普通程序通过系统调用来访问系统资源。

系统资源有以下类型：
1. 处理器，负责调度程序何时执行
2. 输出输出I/O，所有的I/O都必须流经内核，进程集中式管理
3. 进程管理
4. 内存，程序必须要被装载到内存中才能运行
5. 设备，对普通程序屏蔽了复杂的外设使用方法。普通程序只需一个简单的请求即可访问操作
6. 计时器
7. 进程间通信
8. 网络

## 登陆过程
开机，登陆。这么一个简单的过程，发生了什么？

在登陆过程中，当用户名和密码通过验证之后，系统会启动一个shell的进程，然后把用户交给这个进程，由这个进程来处理用户的请求。每个用户都有属于自己的shell进程。

内核运行在内存中，shell为用户提供服务，shell和用户之间的连接由内核来控制。

unix不提供恢复删除功能，这是因为unix是一个多用户系统，一个地址空间是可以被多个用户使用的。

## 系统调用
每次的系统调用都会导致用户模式和内核模式的切换，与及执行内核代码，所以减少系统调用次数，是可以提高程序的运行效率的。

可以通过缓存技术来减少系统调用的次数，仅当缓冲区满或者空的时候才调用内核服务（理论上）。

## 内核缓冲区和进程缓冲区
一个普通程序P希望读取磁盘上的信息，这个过程发生了什么？

![内核缓冲区和普通进程缓冲区](https://github.com/Kevin-fqh/learning-k8s-source-code/blob/master/images/内核缓冲区和普通进程缓冲区.png)

当一个用户空间中的进程要求从磁盘上读取数据的时候，内核一般是不会直接读磁盘的，而是将内核缓冲区的数据复制到进程缓冲区中。具体步骤如下：

1. P向内核发起一个请求，要求读取数据。
2. 内核会检查自身的`内核缓冲区`，如果有P要求的数据，则直接把数据copy到程序P的缓冲区中
3. 如果`内核缓冲区`中没有命中，内核会相应数据快加入请求队列中，把P进程挂起，为其他进程服务。
4. 一段时间后（实际很短），内核从`磁盘`把相应数据读取到了内核缓冲区中了，会把数据copy到进程P的缓冲区中，然后唤起进程P。

所以系统调用 read()和 write()仅仅是`进程缓冲区`和`内核缓冲区`的数据交换！ 而并不是内核缓冲区和磁盘的数据交换。

理论上，内核随时会进行写磁盘操作，但实际上，一般是把要写的数据暂存在内核缓冲区中，积累到一定数量之后，再写入到磁盘。所以，如果突然断电等情况，会发生数据丢失的情况。

所以使用内核缓冲技术，一方面提高了磁盘I/O效率、优化磁盘的写效率，另一方面也需要及时地将缓冲数据写入磁盘。

## 文件描述符fd
进程对文件的读/写都要通过文件描述符fd，文件描述符表示文件和进程间的连接。

一个进程打开一个文件时，内核会为该文件维持一个位置指针，该指针和fd绑定，而不是和文件本身绑定。
这也就是说，两个进程打开同一个文件，产生了两个fd，指针位置互不干扰，对文件的读操作当扰也互不干扰了。

系统调用read()，从文件读取数据时，内核从指针所指明的地方开始，读取指定的字节，然后移动位置指针，指向下一个未被读取的字节。 
写操作也是类似。

所以fd的特点总结如下：
1. 每一个进程都有自己的文件描述符集合。
2. 当创建进程时,通常默认会有3个文件描述符(0,1,2),0代表标准输入，1代表标准输出，2代表标准错误，它们统称为标准IO，所以如果进程通过open打开一个文件的时候，文件描述符会从3开始。
3. 由于文件描述符在一个进程中是特有的,因此不能在多个进程中间实现共享,而唯一的例外是在父/子进程之间,当一个进程调用fork时,调用fork时打开的所有文件在子进程和父进程中仍然是打开的,而且子进程写入文件描述符会影响到父进程的同一文件描述符,反之亦然。
4. 文件描述符是一个简单的整数，用以标明每一个被进程所打开的文件或socket。 
5. fd在open时产生，起到一个索引的作用，进程通过PCB中的文件描述符表找到该fd所指向的文件指针file。

## 目录和文件
目录是一种特殊的文件，其内容只能是 子目录/文件名 的列表。 
与普通文件不同，目录永远不会空。每个目录至少都会包含两个特殊的项：`.`和`..`，分别代表当前目录和上一级目录。

`ls -l`列出的7个字段属性含义如下：
1. 模式 每一行的第一个字符表示文件类型，剩下9个分别表示用户、同组用户、其他用户的的读权限、写权限和执行权限
2. 链接数 该文件被引用的次数
3. 文件所有者，默认是创建文件的用户。
4. 组
5. 大小
6. 最后修改时间
7. 文件名

文件类型一般有普通文件、目录文件、设备文件、socket文件、符号链接文件、命名管道文件等。 
文件类型是在创建的时候就指定，一经创建，无法更改。

文件的权限属性可以通过`chmod`来进行更改。
文件所有者和Group可以通过`chrown`来修改。
文件所有者可以把文件的Group改成任何一个他所属的组。

每一个文件都有三个时间属性，最后修改时间、最后访问时间、属性最后修改时间。 可以使用系统调用或者`touch`来修改时间属性。

## /etc/passwd文件
```shell
root@fqhnode:~# cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
```

这是一个纯文本文件，每一行代表了一个用户，用冒号`:`分成不同的字段，所有用户对这个文件都有读的权限。每个属性具体含义如下：
1. 用户名
2. 密码
3. 用户ID
4. 字段所属的Group,这是该用户的主Group
5. 用户的全名
6. 主目录
7. 用户使用的shell程序的路径

## /etc/group文件
```shell
root@fqhnode:~# cat /etc/group
root:x:0:
daemon:x:1:
sambashare:x:117:fqh
```
1. 组名
2. 组密码
3. 组ID
4. 组成员

一个组可以包含多个成员

## 目录树
`du`是disk usage的缩写，该命令给出指定目录及其子目录下所有文件占用硬盘中数据块的总数。

目录树的深度理论上是没有限制的。

根目录的特别之处，当前目录和父目录都是自己，可以看出inode都是2。
```shell
root@fqhnode:/# pwd
/
root@fqhnode:/# ll -ai
total 100
     2 drwxr-xr-x  24 root root  4096 Jan  7 02:41 ./
     2 drwxr-xr-x  24 root root  4096 Jan  7 02:41 ../
262146 drwxr-xr-x   2 root root  4096 Dec 13 19:54 bin/
```
系统调用`mkfs`比较特别，创建了一个文件系统，并将根目录的父目录指向自己。

## 文件系统的实现
一个文件系统的内容可以分为三部分：
1. 文件系统本身的元数据，称为超级块。一般会有一个备份，否则超级块数据丢失了，就相当于整个文件系统没了。
2. `i-节点`列表，记录了inode信息
3. 数据区域，存放具体的业务数据

`cat`一个文件的流程是：
1. 在目录中寻找文件名，因为文件名记录在目录内容中
2. 从文件名得知其inode号，根据inode号访问`i-节点`区域，获取具体数据快存储位置信息
3. 访问数据块信息，内核读取到内核缓冲区，再送达用户空间。

一般说文件在目录中，其实目录中仅是记录着一个文件在`i-节点`区域的入口，而文件的内容则是存放在数据区。
![文件系统的不同视角-1](https://github.com/Kevin-fqh/learning-k8s-source-code/blob/master/images/文件系统的不同视角-1.png)


硬链接：下面的402节点就是硬链接的实现效果。链接是对i-node节点的引用，可以对一个文件创建任意多的链接。
![文件系统的不同视角-2](https://github.com/Kevin-fqh/learning-k8s-source-code/blob/master/images/文件系统的不同视角-2.png)

link拒绝创建跨越设备的硬链接，rename拒绝在不同的文件系统之间进行`i-节点号`的转移。因为两个文件系统之间的inode号可能会出现冲突。

硬链接是通过inode号来引用文件的，这也是为什么硬链接文件的inode号和其原文件一样。
```shell
[root@fqhnode01 ~]# pwd
/root
[root@fqhnode01 ~]# ln /home/expend-disk/aa tttt
ln: 无法创建硬链接"tttt" => "/home/expend-disk/aa": 无效的跨设备连接
```
用户看到的时候一颗完好的目录树，但实际上有两颗树，每棵树都有一个根目录。内核会通过`mount`把两个文件系统联系起来，但两个文件系统之间的`inode`信息是互相独立的。
![多个文件系统的组合](https://github.com/Kevin-fqh/learning-k8s-source-code/blob/master/images/多个文件系统的组合.png)

link可以通过创建`软链接`来实现这种跨系统的链接形式，虽然可能会形成死循环。
软链接并不存储文件的inode信息，内核使用`名字`来找到原始文件。
软链接是通过名字来引用文件（目录），而不是`inode`信息。
这也是为什么软连接文件的inode号和其指向的文件不一样。

磁盘空间不足，有可能是数据存储区域空间不足；也有可能是`i-节点区`空间不足，即使数据存储区还有空间。

## 外设等设备
`stty`用来让用户检测、修改控制键盘和显示器连接属性的设置。

对于Unix来说，声卡、鼠标这些外设都是同一种对象。 
在Unix系统中，每个设备都被当作一个文件。
每个设备都有一个文件名、一个inode号、一个文件所有者、一个权限位的集合、最后修改时间。 
所有文件的一切都适用于终端和其他设备。

键盘输入就像数据一样被进程读取，而另一个进程把写入的终端的字符显示在屏幕上。

设备的文件一般存在于`/dev`目录下，其中`tty*`类型是终端。
程序通过读取这些文件获取用户的键盘输入，通过写入这些文件向终端屏幕发送数据。

理论上，和文件相关的系统调用，都支持用到设备上。

当你移动鼠标并按下键，鼠标把数据发送给系统，使得进程能够读取他们。 
/dev/mouse文件不支持所有的write系统调用，所以向鼠标写入数据，是不会发生啥的。 
`终端`支持read和write，但不支持lseek。

终端包括输入输出等各种设备，甚至一个ssh窗口也是。

### 向终端写入数据
`tty`获取当前终端设备文件，然后像操作普通文件写入数据，会直接显示在当前终端-屏幕。
```shell
[root@fqhnode01 ~]# tty
/dev/pts/1
[root@fqhnode01 ~]# echo "hello">/dev/pts/1
hello
[root@fqhnode01 ~]# cp test.txt /dev/pts/1
cp：是否覆盖"/dev/pts/1"？ y
aaa
aaa
```
设备文件是一个链接，而不是容器。

设备文件的inode节点存储的是指向内核子程序的指针，而不是文件的大小和存储列表。 内核中传输设备数据的子程序被称为设备驱动程序。
```shell
[root@fqhnode01 ~]# ll /dev/pts/1 -i
4 crw--w----. 1 root tty 136, 1 1月  20 10:29 /dev/pts/1
```
在这里，`136`并不是这个终端设备文件的大小，而是表示`进程表中编号为136的子程序`。 
同时发现该终端文件的文件类型是`c`，如read()这些系统调用会根据该文件类型来决定下一步操作。
![设备文件和普通数据文件的区别](https://github.com/Kevin-fqh/learning-k8s-source-code/blob/master/images/设备文件和普通数据文件的区别.png)

### 设备文件和普通磁盘文件的区别
通常用系统调用open()来创建与文件和设备的连接，如下图所示，一个进程拥有两个fd。
![设备文件和普通磁盘文件的区别](https://github.com/Kevin-fqh/learning-k8s-source-code/blob/master/images/设备文件和普通磁盘文件的区别.png)

与磁盘文件文件的连接，通常包含内核缓冲区，从进程到磁盘的字节先被缓冲，然后才用内核缓冲区被发送出去。

到终端的连接则不同，进程需要尽快把终端的数据发送出去。

任何数据的源或目的地都被Unix视为文件，基本的系统调用既适用于磁盘文件，也同样适用于设备文件，它们的区别体现在对连接的操作上。 
磁盘文件的文件描述符fd包含定义了缓冲属性和扩展属性的代码。 
而终端文件的fd包含了定义编辑、回显、字符串转换等操作属性的代码。

### 自动添加模式
试想多个进程同时写入一个文件？这产生了竞争，内核通过把`lseek`和`write`两个系统调用合并成一个`原子操作`来解决这个问题。


## 信号
信号是从内核发送给进程一种简短消息。信号可能来自于用户、其他进程或内核本身。进程可以告诉内核，在它收到信号时需要做出怎样的相应。

### 源头
信号从哪里来？信号来自于内核，生成信号的请求来自三个地方：
1. 用户发送请求（按下Ctrl+C），请求内核产生信号。这类型被称为异步信号
2. 进程运行出错，内核给该进程发送一个信号，如溢出、越界等
3. 一个进程可以通过系统调用kill给另一个进程发送信号，两个进程可以通过信号进行通信。这类型被称为同步信号

很多信号杀死进程，某时刻进程p还在运行，下一秒就消亡了，从内存中删除，相应的所有的文件描述符fd被关闭，并且从进程表中删除。 
使用信号SIGINT消灭一个进程，但进程也有办法保护自己不被杀死。

### 进程该如何处理信号
一个进程接收到信号SIGINT时，不一定要消亡。 
他可以通过系统调用`signal`来告诉内核，自身要如何处理该信号，一般有三种情况可以选择：
1. 接受默认处理，signal(SIGINT, SIG_DFL)，其中SIG_DFL表示将信号恢复默认处理
2. 忽略信号，signal(SIGINT, SIG_IGN)，其中SIG_IGN表示忽略信号
3. 调用一个函数，这是最强大的一种。signal(signum, functionName),其中signum表示信号

举个例子，如果进程接收到SIGINT信号，内核会调用函数f来处理这个信号。程序跳转到函数f()，执行其代码，然后返回跳转前的位置，就像子过程调用一样。
![系统信号](https://github.com/Kevin-fqh/learning-k8s-source-code/blob/master/images/系统信号.png)

大多数的信号都可以被忽略和捕捉，但`SIGKILL`和`SIGSTOP`两个信号是不可以被忽略和捕捉的。原因是：它们向超级用户提供一种使进程终止或停止的可靠方法。

处理一个信号会比较简单，但如果一个进程同时收多个信号，就比较复杂了。

## 计时器
进程通过设置计时器来安排事件，一个进程有三个独立的计时器，计时器通过发送信号来通知进程。 
每个计时器都可以被设置为只发送一次信号，或者按固定的间隙发送信号。
![一个进程的三个计时器](https://github.com/Kevin-fqh/learning-k8s-source-code/blob/master/images/一个进程的三个计时器.png)






